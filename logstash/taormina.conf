input {
    udp {
        host => "0.0.0.0"
        port => "5514"
        type => "udp"
        tags => [ "pensando_flowlog" ]
    }
}
filter {
  dissect {
    mapping => { 'message' => '<%{syslog_priority}>%{syslog_version} %{gen_time} %{hostname} %{proc_name} %{proc_id} %{msg_id} %{sd} %{csv_message}'}
  }
  dissect {
    mapping => { 'csv_message' => '%{timestamp},%{[session][state]},%{[session][action]},%{vpc_id},%{[source][ip]},%{[source][port]},%{[destination][ip]},%{[destination][port]},%{protocol},%{[session][id]},%{[security][policy_id]},%{[security][rule_id]},%{[security][rule_name]},%{[session][iflow_pkts]},%{[session][iflow_bytes]},%{[session][rflow_pkts]},%{[session][rflow_bytes]},%{[source][vlan]},%{[dsx][type]},%{[dsx][sw_ver]},%{[dsx][ser_num]},%{[dsx][device_name]},%{[dsx][unit_id]},%{version}'}
  }
  date
  {
    match => ["timestamp", "ISO8601"]
    target => "@timestamp"
    }
  mutate {
    remove_field => [ "message" ]
    remove_field => [ "csv_message" ]
    remove_field => [ "timestamp" ]
    rename => { "type" => "syslog_proto" }

  }

  # mutate {
  #     convert => [ "Bytes", "integer" ]
  #     convert => [ "BytesReceived", "integer" ]
  #     convert => [ "BytesSent", "integer" ]
  #     convert => [ "ElapsedTime", "integer" ]
  #     convert => [ "GeoIP.dma_code", "integer" ]
  #     convert => [ "GeoIP.latitude", "float" ]
  #     convert => [ "GeoIP.longitude", "float" ]
  #     convert => [ "NATDestinationPort", "integer" ]
  #     convert => [ "NATSourcePort", "integer" ]
  #     convert => [ "Packets", "integer" ]
  #     convert => [ "PacketsReceived", "integer" ]
  #     convert => [ "PacketsSent", "integer" ]
  #     convert => [ "SequenceNumber", "integer" ]
  #     add_tag => [ "PAN-OS_traffic"]
  # }
}
#         }
#         # Threat log fields: https://www.paloaltonetworks.com/documentation/80/pan-os/pan-os/monitoring/syslog-field-descriptions#_67983
#         else if ([message] =~ /THREAT/) {
#             csv {
#                 source => "message"
#                 columns => [
#                     "Domain", "ReceiveTime", "SerialNumber", "Type", "Threat_ContentType", "Config Version",
#                     "GeneratedTime", "SourceIP", "DestinationIP", "NATSourceIP", "NATDestinationIP", "RuleName",
#                     "SourceUser", "DestinationUser", "Application", "VirtualSystem", "SourceZone", "DestinationZone",
#                     "InboundInterface", "OutboundInterface", "LogForwardingProfile", "Time Logged", "SessionID",
#                     "RepeatCount", "SourcePort", "DestinationPort", "NATSourcePort", "NATDestinationPort", "Flags",
#                     "Protocol", "Action", "Miscellaneous", "ThreatID", "URLCategory", "Severity", "Direction",
#                     "SequenceNumber", "ActionFlags", "SourceLocation", "DestinationLocation", "cpadding",
#                     "ContentType", "PCAP_ID", "FileDigest", "Cloud", "URLIndex", "UserAgent", "FileType",
#                     "X-Forwarded-For", "Referer", "Sender", "Subject", "Recipient", "ReportID",
#                     "DeviceGroupHierarchyLevel1", "DeviceGroupHierarchyLevel2", "DeviceGroupHierarchyLevel3",
#                     "DeviceGroupHierarchyLevel4", "VirtualSystemName", "DeviceName", "File_URL", "SourceVMUUID",
#                     "DestinationVMUUID", "HTTPMethod", "TunnelID_IMSI", "MonitorTag_IMEI", "ParentSessionID",
#                     "ParentStartTime", "TunnelType", "ThreatCategory", "ContentVersion", "SigFlags"
#                 ]
#             }
#             mutate {
#                 convert => [ "GeoIP.dma_code", "integer" ]
#                 convert => [ "GeoIP.latitude", "float" ]
#                 convert => [ "GeoIP.longitude", "float" ]
#                 convert => [ "NATDestinationPort", "integer" ]
#                 convert => [ "NATSourcePort", "integer" ]
#                 convert => [ "SequenceNumber", "integer" ]

#                 add_tag => ["PAN-OS_threat"]
#             }

#             # Further categorization of messages for SafeNetworking to work on

#             # SFN URL
#             if ([Threat_ContentType] =~ "url") {
#                 mutate {
#                     add_field => {"[SFN][url_name]" => "%{Miscellaneous}"}
#                     add_field => {"[SFN][url_category]" => "%{URLCategory}"}
#                     add_field => {"[SFN][processed]" => 0}

#                     add_tag => ["SFN-URL"]
#                     # Don't need the fields we moved under SFN - save some electrons
#                     remove_field => [ "Miscellaneous","URLCategory" ]
#                 }
#             }

#             # SFN DNS
#             if ([ThreatCategory] =~ "^dns") {
#                 if ([ThreatID] =~ "^Suspicious DNS Query") {
#                     grok {
#                         match => {"ThreatID" => "^Suspicious DNS Query \(%{DATA:[SFN][threat_name]}:?.%{HOSTNAME:[SFN][domain_name]}\)\(%{NUMBER:[SFN][sig_num]}\)"}
#                         add_field => {"[SFN][processed]" => 0}
#                         add_tag => [ "SFN-DNS" ]
#                     }
#                 }
#                 else {
#                     grok {
#                         match => {"ThreatID" => "%{DATA:[SFN][threat_name]}:%{HOSTNAME:[SFN][domain_name]}\(%{NUMBER:[SFN][sig_num]}\)"}
#                         add_field => {"[SFN][processed]" => 0}
#                         add_tag => [ "SFN-DNS" ]
#                     }
#                 }

#             # The following sections are OPTIONAL

#             # Uncomment the mutate and dns sections if you want to
#             # resolve the malicious domain.  This requires that the logging system is NOT behind a FW that
#             # will report the DNS query as a threat or you will have recursion from hell.
#             # Copy the domain_name field to the resolved_ip so when we do the dns resolution, it automatically
#             # overwrites the resolved_ip field with the IP of the domain the user was trying to resolve
#             #     mutate {
#             #             copy => { "[SFN][domain_name]" => "[SFN][resolved_ip]"}
#             #     }

#             #    dns {
#             #        timeout => 1
#             #        resolve => [ "[SFN][resolved_ip]" ]
#             #        action => "replace"
#             #    }

#                 elasticsearch {
#                     hosts => ["elasticsearch"]
#                     index => ["customer-db"]
#                     query => "imsi:%{[TunnelID_IMSI]}"
#                     fields => { "name" => "[CUSTOMER][name]" }
#                     fields => { "address" => "[CUSTOMER][address]" }
#                     fields => { "city" => "[CUSTOMER][city]" }
#                     fields => { "country" => "[CUSTOMER][country]" }
#                     fields => { "zip" => "[CUSTOMER][zip]" }
#                     fields => { "phone" => "[CUSTOMER][phone]" }
#                     fields => { "email" => "[CUSTOMER][email]" }
#                     fields => { "acct_number" => "[CUSTOMER][acct_number]" }
#                     fields => { "imsi" => "[CUSTOMER][imsi]" }
#                     fields => { "imei" => "[CUSTOMER][imei]" }
#                     fields => { "ip_addr" => "[CUSTOMER][ip_addr]" }
#                 }
#             }
#         }


#         # Original message has been fully parsed, so remove it.
#         mutate {
#             remove_field => [ "message" ]
#         }
#         # Geolocate logs that have SourceIP if that SourceIP is a non-RFC1918 address
#         if [SourceIP] and [SourceIP] !~ "(^127\.0\.0\.1)|(^10\.)|(^172\.1[6-9]\.)|(^172\.2[0-9]\.)|(^172\.3[0-1]\.)|(^192\.168\.)|(^169\.254\.)" {
#             geoip {
#                source => "SourceIP"
#                target => "SourceIPGeo"
#           }
#             # Delete 0,0 in SourceIPGeo.location if equal to 0,0
#             if ([SourceIPGeo.location] and [SourceIPGeo.location] =~ "0,0") {
#                 mutate {
#                     replace => [ "SourceIPGeo.location", "" ]
#                 }
#             }
#         }
#         # Geolocate logs that have DestinationIP and if that DestinationIP is a non-RFC1918 address
#         if [DestinationIP] and [DestinationIP] !~ "(^127\.0\.0\.1)|(^10\.)|(^172\.1[6-9]\.)|(^172\.2[0-9]\.)|(^172\.3[0-1]\.)|(^192\.168\.)|(^169\.254\.)" {
#             geoip {
#                 source => "DestinationIP"
#                 target => "DestinationIPGeo"
#             }

#             # Delete 0,0 in DestinationIPGeo.location if equal to 0,0
#             if ([DestinationIPGeo.location] and [DestinationIPGeo.location] =~ "0,0") {
#                 mutate {
#                     replace => [ "DestinationIPGeo.location", "" ]
#                 }
#             }
#         }
#         # Takes the 5-tuple of source address, source port, destination address, destination port, and protocol and does a SHA1 hash to fingerprint the flow.  This is a useful
#         # way to be able to do top N terms queries on flows, not just on one field.
#         if [SourceIP] and [DestinationIP] {
#             fingerprint {
#                 concatenate_sources => true
#                 method => "SHA1"
#                 key => "logstash"
#                 source => [ "SourceIP", "SourcePort", "DestinationIP", "DestinationPort", "Protocol" ]
#             }
#         }
#     metrics {
#         meter => "events"
#         add_tag => "metric"
#     }
#   }

output {
  elasticsearch {
        hosts    => [ 'elasticsearch' ]
        index => "test-%{+YYYY.MM}"
    }

    #stdout { codec => rubydebug }
}
